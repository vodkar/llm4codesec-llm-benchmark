[
    {
        "CWE": 787,
        "vul-code": "char* trimTrailingWhitespace(char *strMessage, int length) {\nchar *retMessage;\nchar *message = malloc(sizeof(char)*(length+1));\n\n// copy input string to a temporary string\nchar message[length+1];\nint index;\nfor (index = 0; index < length; index++) {\nmessage[index] = strMessage[index];\n}\nmessage[index] = '\\0';\n\n// trim trailing whitespace\nint len = index-1;\nwhile (isspace(message[len])) {\nmessage[len] = '\\0';\nlen--;\n}\n\n// return string without trailing whitespace\nretMessage = message;\nreturn retMessage;\n}",
        "vul-explanation": "In the code, a utility function is used to trim trailing whitespace from a character string. The function copies the input string to a local character string and uses a while statement to remove the trailing whitespace by moving backward through the string and overwriting whitespace with a NULL character. However, this function can cause a buffer underwrite if the input character string contains all whitespace. On some systems the while statement will move backwards past the beginning of a character string and will call the `isspace()` function on an address outside of the bounds of the local buffer.",
        "sec-code": "char* trimTrailingWhitespace(char *strMessage, int length) {\nchar *retMessage;\nchar *message = malloc(sizeof(char)*(length+1));\n\n// copy input string to a temporary string\nchar message[length+1];\nint index;\nfor (index = 0; index < length; index++) {\nmessage[index] = strMessage[index];\n}\nmessage[index] = '\\0';\n\n// trim trailing whitespace\nint len = index-1;\nwhile (len >= 0 && isspace(message[len])) {\nmessage[len] = '\\0';\nlen--;\n}\n\n// return string without trailing whitespace\nretMessage = message;\nreturn retMessage;\n}",
        "sec-explanation": "In the code, a utility function is used to trim trailing whitespace from a character string. The function copies the input string to a local character string and uses a while statement to remove the trailing whitespace by moving backward through the string and overwriting whitespace with a NULL character. This function avoids a buffer underwrite by incorporating the boundary check `len >= 0` in the while loop condition. This ensures that the loop does not move past the beginning of the character string or call the `isspace()` function on an address outside the bounds of the buffer."
    },
    {
        "CWE": 125,
        "vul-code": "int getValueFromArray(int *array, int len, int index) {\n\nint value;\n\n// check that the array index is less than the maximum\n\n// length of the array\nif (index < len) {\n\n// get the value at the specified index of the array\nvalue = array[index];\n}\n// if array index is invalid then output error message\n\n// and return value indicating error\nelse {\nprintf(\"Value is: %d\\n\", array[index]);\nvalue = -1;\n}\n\nreturn value;\n}",
        "vul-explanation": "In the code, the method retrieves a value from an array at a specific array index location that is given as an input parameter to the method. However, this method only verifies that the given array index is less than the maximum length of the array but does not check for the minimum value (CWE-839). This will allow a negative value to be accepted as the input array index, which will result in a out of bounds read (CWE-125) and may allow access to sensitive memory. The input array index should be checked to verify that is within the maximum and minimum range required for the array (CWE-129).",
        "sec-code": "int getValueFromArray(int *array, int len, int index) {\n\nint value;\n\n// check that the array index is less than the maximum\n\n// length of the array\nif (index >= 0 && index < len) {\n\n// get the value at the specified index of the array\nvalue = array[index];\n}\n// if array index is invalid then output error message\n\n// and return value indicating error\nelse {\nprintf(\"Value is: %d\\n\", array[index]);\nvalue = -1;\n}\n\nreturn value;\n}",
        "sec-explanation": "In the code, the method retrieves a value from an array at a specific array index location that is given as an input parameter to the method. This method ensures that the given array index is greater than or equal to zero and less than the maximum length of the array. By validating the input index, it prevents out-of-bounds reads (CWE-125) and avoids unintended access to sensitive memory."
    },
    {
        "CWE": 78,
        "vul-code": "int main(int argc, char** argv) {\n    char cmd[CMD_MAX] = \"/usr/bin/cat \";\n    strcat(cmd, argv[1]);\n    system(cmd);\n}",
        "vul-explanation": "The code accepts a filename as a command line argument and displays the contents of the file back to the user. The program is installed setuid root because it is intended for use as a learning tool to allow system administrators in-training to inspect privileged system files without giving them the ability to modify them or damage the system. Because the program runs with root privileges, the call to `system()` also executes with root privileges. If a user specifies a standard filename, the call works as expected. However, if an attacker passes a string of the form \";rm -rf /\", then the call to `system()` fails to execute cat due to a lack of arguments and then plows on to recursively delete the contents of the root partition.",
        "sec-code": "int main(int argc, char** argv) {\n    if (argc != 2) {\n        fprintf(stderr, \"Usage: %s <filename>\\n\", argv[0]);\n        return EXIT_FAILURE;\n    }\n\n    // Validate the input filename\n    const char *filename = argv[1];\n    if (strchr(filename, '/') != NULL || strchr(filename, ';') != NULL || strchr(filename, '|') != NULL) {\n        fprintf(stderr, \"Invalid filename\\n\");\n        return EXIT_FAILURE;\n    }\n\n    // Construct the full path securely\n    char cmd[CMD_MAX];\n    snprintf(cmd, CMD_MAX, \"/usr/bin/cat %s\", filename);\n\n    // Use execlp to execute the command without invoking the shell\n    execlp(\"/usr/bin/cat\", \"cat\", filename, NULL);\n\n    // If execlp fails\n    perror(\"execlp\");\n    return EXIT_FAILURE;\n}",
        "sec-explanation": "The code accepts a filename as a command line argument and displays the contents of the file back to the user. The program is installed setuid root because it is intended for use as a learning tool to allow system administrators in-training to inspect privileged system files without giving them the ability to modify them or damage the system. To prevent command injection vulnerabilities, the program validates the filename to ensure it does not contain special characters that could facilitate such attacks. Additionally, it uses `execlp()` instead of `system()` to directly execute the cat command without invoking a shell, thereby eliminating the risk of shell interpretation."
    },
    {
        "CWE": 416,
        "vul-code": "char* ptr = (char*)malloc (SIZE);\nif (err) {\n    abrt = 1;\n    free(ptr);\n}\n...\nif (abrt) {\n    logError(\"operation aborted before commit\", ptr);\n}",
        "vul-explanation": "In the code, when an error occurs, the pointer `ptr` is immediately freed. However, this pointer is later incorrectly used in the logError function.",
        "sec-code": "char* ptr = (char*)malloc (SIZE);\nif (err) {\n    abrt = 1;\n    free(ptr);\n    ptr = NULL;}\n...\nif (abrt) {\n    logError(\"operation aborted before commit\", ptr);\n}",
        "sec-explanation": "In the code, when an error occurs, the program releases the memory pointed to by `ptr` using `free(ptr)`, returning the allocated memory to the system. Immediately afterward, `ptr` is set to `NULL`, ensuring that it no longer points to the now-invalid memory. When `logError` is later called, the `ptr` value passed is `NULL`. Since `NULL` is universally recognized as an invalid or empty pointer, this prevents any access to the freed memory. Nullifying `ptr` ensures that any attempt to dereference it results in a clear failure, such as a null pointer access error, which is easier to debug and far less harmful than a use-after-free vulnerability."
    },
    {
        "CWE": 20,
        "vul-code": "...\n#define MAX_DIM 100\n...\n/* board dimensions */\n\nint m,n, error;\nboard_square_t *board;\nprintf(\"Please specify the board height: \\n\");\nerror = scanf(\"%d\", &m);\nif ( EOF == error ){\ndie(\"No integer passed: Die evil hacker!\\n\");\n}\nprintf(\"Please specify the board width: \\n\");\nerror = scanf(\"%d\", &n);\nif ( EOF == error ){\ndie(\"No integer passed: Die evil hacker!\\n\");\n}\nif ( m > MAX_DIM || n > MAX_DIM ) {\ndie(\"Value too large: Die evil hacker!\\n\");\n}\nboard = (board_square_t*) malloc( m * n * sizeof(board_square_t));\n...",
        "vul-explanation": "This code asks the user for a height and width of an `m X n` game board with a maximum dimension of 100 squares. While this code checks to make sure the user cannot specify large, positive integers and consume too much memory, it does not check for negative values supplied by the user. As a result, an attacker can perform a resource consumption (CWE-400) attack against this program by specifying two, large negative values that will not overflow, resulting in a very large memory allocation (CWE-789) and possibly a system crash. Alternatively, an attacker can provide very large negative values which will cause an integer overflow (CWE-190) and unexpected behavior will follow depending on how the values are treated in the remainder of the program.",
        "sec-code": "...\n#define MAX_DIM 100\n...\n/* board dimensions */\n\nint m, n, error;\nboard_square_t *board;\n\nprintf(\"Please specify the board height: \\n\");\nerror = scanf(\"%d\", &m);\nif (error == EOF || m <= 0 || m > MAX_DIM) {\n    die(\"Invalid height: Height must be a positive integer within the allowed range.\\n\");\n}\n\nprintf(\"Please specify the board width: \\n\");\nerror = scanf(\"%d\", &n);\nif (error == EOF || n <= 0 || n > MAX_DIM) {\n    die(\"Invalid width: Width must be a positive integer within the allowed range.\\n\");\n}\n\n// Check for integer overflow in memory allocation\nif (m > SIZE_MAX / (n * sizeof(board_square_t))) {\n    die(\"Memory allocation overflow: Requested board size is too large.\\n\");\n}\n\nboard = (board_square_t *)malloc(m * n * sizeof(board_square_t));",
        "sec-explanation": "This code asks the user for a height and width of an `m X n` game board with a maximum dimension of 100 squares. The program validates that `m` and `n` are positive integers within the allowed range of 1 to `MAX_DIM` by evaluating the conditions `m <= 0 || m > MAX_DIM` and `n <= 0 || n > MAX_DIM`. These input validation checks prevent a resource consumption vulnerability (CWE-400) by rejecting large negative values that could otherwise bypass the intended range and trigger excessive memory allocation (CWE-789), potentially leading to a system crash. Furthermore, before allocating memory, the program verifies that the expression `m * n * sizeof(board_square_t)` does not exceed `SIZE_MAX`, the maximum allowable value for `size_t`. This additional check prevents integer overflows (CWE-190) that could occur if an attacker provides large negative values, ensuring that the program avoids undefined behavior and remains secure."
    },
    {
        "CWE": 119,
        "vul-code": "void host_lookup(char *user_supplied_addr){\nstruct hostent *hp;\nin_addr_t *addr;\nchar hostname[64];\nin_addr_t inet_addr(const char *cp);\n\n/*routine that ensures user_supplied_addr is in the right format for conversion */\n\nvalidate_addr_form(user_supplied_addr);\naddr = inet_addr(user_supplied_addr);\nhp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);\nstrcpy(hostname, hp->h_name);\n}",
        "vul-explanation": "This code takes an IP address from a user, verifies that it is well formed and then looks up the hostname and copies it into a buffer. This function allocates a buffer of 64 bytes to store the hostname, however there is no guarantee that the hostname will not be larger than 64 bytes. If an attacker specifies an address which resolves to a very large hostname, then the function may overwrite sensitive data or even relinquish control flow to the attacker.",
        "sec-code": "void host_lookup(char *user_supplied_addr) {\n    struct hostent *hp;\n    in_addr_t *addr;\n    char hostname[64]; // Allocate buffer with room for null terminator\n    in_addr_t inet_addr(const char *cp);\n\n    /* Routine that ensures user_supplied_addr is in the right format for conversion */\n    \n    validate_addr_form(user_supplied_addr);\n    addr = inet_addr(user_supplied_addr);\n    hp = gethostbyaddr(addr, sizeof(struct in_addr), AF_INET);\n\n    // Ensure that we do not overflow the hostname buffer\n    snprintf(hostname, sizeof(hostname), \"%s\", hp->h_name);\n}",
        "sec-explanation": "This code takes an IP address from a user, verifies that it is well-formed, and then looks up the hostname, copying it into a buffer. The function initially allocates a buffer of 64 bytes to store the hostname. However, since the hostname could be larger than 64 bytes, this presents a risk of buffer overflow. To address this, the `snprintf` function is used instead of `strcpy` to ensure the buffer is not overflowed. `snprintf` guarantees that only up to `sizeof(hostname)` characters are copied, thereby preventing a buffer overflow."
    },
    {
        "CWE": 476,
        "vul-code": "void host_lookup(char *user_supplied_addr){\nstruct hostent *hp;\nin_addr_t *addr;\nchar hostname[64];\nin_addr_t inet_addr(const char *cp);\n\n/*routine that ensures user_supplied_addr is in the right format for conversion */\n\nvalidate_addr_form(user_supplied_addr);\naddr = inet_addr(user_supplied_addr);\nhp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);\nstrcpy(hostname, hp->h_name);\n}",
        "vul-explanation": "This code takes an IP address from a user, verifies that it is well formed and then looks up the hostname and copies it into a buffer. If an attacker provides an address that appears to be well-formed, but the address does not resolve to a hostname, then the call to `gethostbyaddr()` will return NULL. Since the code does not check the return value from gethostbyaddr (CWE-252), a NULL pointer dereference (CWE-476) would then occur in the call to `strcpy()`.",
        "sec-code": "void host_lookup(char *user_supplied_addr){\nstruct hostent *hp;\nin_addr_t *addr;\nchar hostname[64];\nin_addr_t inet_addr(const char *cp);\n\n/*routine that ensures user_supplied_addr is in the right format for conversion */\n\nvalidate_addr_form(user_supplied_addr);\naddr = inet_addr(user_supplied_addr);\nhp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET);\nif (hp == NULL) {\n    fprintf(stderr, \"Host lookup failed for address: %s\n\", user_supplied_addr);\n    return;  // Return or handle the error as needed\n}\nstrcpy(hostname, hp->h_name);\n}",
        "sec-explanation": "This code takes an IP address from a user, verifies that it is well-formed, and then looks up the hostname, copying it into a buffer. If an attacker provides an address that appears to be well-formed but does not resolve to a hostname, the call to `gethostbyaddr()` will return NULL. To prevent a NULL pointer dereference (CWE-476) in the call to `strcpy()`, the code checks the return value from `gethostbyaddr()` before attempting to dereference the pointer `hp`."
    },

    {
        "CWE": 798,
        "vul-code": "int VerifyAdmin(char *password) {\n    if (strcmp(password,\"68af404b513073584c4b6f22b6c63e6b\")) {\n\n    printf(\"Incorrect Password!\\n\");\n        return(0);\n    }\n    printf(\"Entering Diagnostic Mode...\\n\");\n    return(1);\n}",
        "vul-explanation": "The code attempts to verify a password using a hard-coded cryptographic key. The cryptographic key is within a hard-coded string value that is compared to the password. It is likely that an attacker will be able to read the key and compromise the system.",
        "sec-code": "int VerifyAdmin(char *password) {\n    if (strcmp(password, getenv(\"ADMIN_PASSWORD\"))) {\n\n    printf(\"Incorrect Password!\\n\");\n        return(0);\n    }\n    printf(\"Entering Diagnostic Mode...\\n\");\n    return(1);\n}\n\n",
        "sec-explanation": "The code attempts to verify a password using a cryptographic key retrieved from the environment variable \"ADMIN_PASSWORD\" using the `getenv` function. This approach helps avoid hard-coded credentials by securely storing the key outside of the source code."
    },
    {
        "CWE": 190,
        "vul-code": "nresp = packet_get_int();\nif (nresp > 0) {\n    response = xmalloc(nresp*sizeof(char*));\n    for (i = 0; i < nresp; i++) response[i] = packet_get_string(NULL);\n}",
        "vul-explanation": "In the code, if `nresp` has the value 1073741824 and `sizeof(char*)` has its typical value of 4, then the result of the operation `nresp*sizeof(char*)` overflows, and the argument to `xmalloc()` will be 0. Most `malloc()` implementations will happily allocate a 0-byte buffer, causing the subsequent loop iterations to overflow the heap buffer response.",
        "sec-code": "nresp = packet_get_int();\nif (nresp > 0  && nresp <= (SIZE_MAX / sizeof(char*))) {\n    response = xmalloc(nresp*sizeof(char*));\n    for (i = 0; i < nresp; i++) response[i] = packet_get_string(NULL);\n}",
        "sec-explanation": "In the code, if `nresp` is too large, the multiplication could exceed the maximum size (`SIZE_MAX`) that can be represented by `size_t`. The check `nresp <= (SIZE_MAX / sizeof(char*))` ensures that multiplying `nresp` by `sizeof(char*)` will not cause an overflow, thereby preventing invalid memory allocation."
    },
    {
        "CWE": 400,
        "vul-code": "int writeDataFromSocketToFile(char *host, int port)\n{\n\nchar filename[FILENAME_SIZE];\nchar buffer[BUFFER_SIZE];\nint socket = openSocketConnection(host, port);\n\nif (socket < 0) {\nprintf(\"Unable to open socket connection\");\nreturn(FAIL);\n}\nif (getNextMessage(socket, filename, FILENAME_SIZE) > 0) {\nif (openFileToWrite(filename) > 0) {\nwhile (getNextMessage(socket, buffer, BUFFER_SIZE) > 0){\nif (!(writeToFile(buffer) > 0))\nbreak;\n}\n}\ncloseFile();\n}\ncloseSocket(socket);\n}",
        "vul-explanation": "In the code, a server socket connection is used to accept a request to store data on the local file system using a specified filename. The method `openSocketConnection` establishes a server socket to accept requests from a client. When a client establishes a connection to this service the getNextMessage method is first used to retrieve from the socket the name of the file to store the data, the `openFileToWrite` method will validate the filename and open a file to write to on the local file system. The `getNextMessage` is then used within a while loop to continuously read data from the socket and output the data to the file until there is no longer any data from the socket. This code creates a situation where data can be dumped to a file on the local file system without any limits on the size of the file. This could potentially exhaust file or disk resources and/or limit other clients' ability to access the service.",
        "sec-code": "int writeDataFromSocketToFile(char *host, int port) {\nchar filename[FILENAME_SIZE];\nchar buffer[BUFFER_SIZE];\nint socket = openSocketConnection(host, port);\n\nif (socket < 0) {\nprintf(\"Unable to open socket connection\");\nreturn(FAIL);\n}\nif (getNextMessage(socket, filename, FILENAME_SIZE) > 0) {\nif (openFileToWrite(filename) > 0) {\noff_t total_written = 0;\nwhile (getNextMessage(socket, buffer, BUFFER_SIZE) > 0){\nif (total_written + strlen(buffer) > MAX_FILE_SIZE) {\nprintf(\"File size limit reached. Aborting write.\\n\");\nbreak;\n}\n\nif (writeToFile(buffer) > 0) {\ntotal_written += strlen(buffer);  // Increment written size\n} else {\nprintf(\"Error writing to file.\\n\");\nbreak;\n}\n}\ncloseFile();\n}\ncloseSocket(socket);\n}",
        "sec-explanation": "In the code, a server socket connection is used to accept a request to store data on the local file system using a specified filename. The method `openSocketConnection` establishes a server socket to accept requests from a client. When a client establishes a connection to this service the `getNextMessage` method is first used to retrieve from the socket the name of the file to store the data, the `openFileToWrite` method will validate the filename and open a file to write to on the local file system. The `getNextMessage` is then used within a while loop to continuously read data from the socket and output the data to the file until there is no longer any data from the socket. During the loop, the `total_written` variable tracks the cumulative amount of data written to the file. Before each write operation, the code checks whether adding the current buffer's size would exceed the maximum allowed file size. If it would, the writing process is halted. This ensures that the service does not run out of disk space or exhaust resources due to excessively large files."
    }
]